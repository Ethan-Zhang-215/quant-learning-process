# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HiCwmyoj0uYTN2n7EaF5Xt4RjXuCaqPJ
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import re
import string
import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, f1_score, roc_auc_score
import tensorflow as tf
from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing.sequence import pad_sequences
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Embedding, LSTM, Dense, Dropout, Conv1D, MaxPooling1D, GlobalMaxPooling1D
from transformers import TFAutoModel, AutoTokenizer
import openai
import requests
import json
import time
import warnings
from sklearn.metrics import confusion_matrix  # 新增此行
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint
warnings.filterwarnings('ignore')

nltk.download('punkt')
nltk.download('stopwords')

openai.api_key = ''  # 请替换为您的OpenAI API密钥
DEEPSEEK_API_KEY = ''  # 请替换为您的Deepseek API密钥

def clean_text(text):
    text = str(text).lower()
    text = re.sub(r'\[.*?\]', '', text)
    text = re.sub(r'https?://\S+|www\.\S+', '', text)
    text = re.sub(r'<.*?>+', '', text)
    text = re.sub(r'[%s]' % re.escape(string.punctuation), '', text)
    text = re.sub(r'\n', '', text)
    text = re.sub(r'\s+', ' ', text).strip()
    return text

from openai import OpenAI

# 初始化客户端
client = OpenAI(api_key="")

def get_chatgpt_sentiment(text):
    """使用ChatGPT进行情感分析"""
    try:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "你是一个情感分析专家。请分析以下文本的情感，只返回'positive'、'negative'或'neutral'。"},
                {"role": "user", "content": text}
            ],
            temperature=0.3,
            max_tokens=10
        )
        sentiment = response.choices[0].message.content.strip().lower()
        return sentiment
    except Exception as e:
        print(f"ChatGPT API错误: {e}")
        return "neutral"

def get_deepseek_sentiment(text):
    """使用Deepseek进行情感分析"""
    try:
        url = "https://api.deepseek.com/v1/chat/completions"
        headers = {
            "Authorization": f"Bearer {DEEPSEEK_API_KEY}",
            "Content-Type": "application/json"
        }
        data = {
            "model": "deepseek-chat",
            "messages": [
                {"role": "system", "content": "你是一个情感分析专家。请分析以下文本的情感，只返回'positive'、'negative'或'neutral'。"},
                {"role": "user", "content": text}
            ],
            "temperature": 0.3,
            "max_tokens": 10
        }
        response = requests.post(url, headers=headers, data=json.dumps(data))
        result = response.json()
        sentiment = result['choices'][0]['message']['content'].strip().lower()
        return sentiment
    except Exception as e:
        print(f"Deepseek API错误: {e}")
        return "neutral"

def evaluate_generative_models(test_df, sample_size=100):
    """评估生成式模型（新增完整指标和可视化）"""
    print("\n评估生成式模型...")

    # 随机采样测试数据
    sample_df = test_df.sample(min(sample_size, len(test_df)))

    # ChatGPT评估
    print("使用ChatGPT进行情感分析...")
    chatgpt_predictions = []
    for text in sample_df['text']:
        sentiment = get_chatgpt_sentiment(text)
        chatgpt_predictions.append(sentiment)
        time.sleep(1)

    # Deepseek评估
    print("使用Deepseek进行情感分析...")
    deepseek_predictions = []
    for text in sample_df['text']:
        sentiment = get_deepseek_sentiment(text)
        deepseek_predictions.append(sentiment)
        time.sleep(1)

    # 标签编码
    sentiment_mapping = {'positive': 2, 'neutral': 1, 'negative': 0}
    y_true = sample_df['sentiment'].map(sentiment_mapping)
    chatgpt_pred = [sentiment_mapping.get(pred, 1) for pred in chatgpt_predictions]
    deepseek_pred = [sentiment_mapping.get(pred, 1) for pred in deepseek_predictions]

    # ============= 新增指标计算 =============
    from sklearn.metrics import precision_score, recall_score, classification_report

    # ChatGPT指标
    chatgpt_accuracy = accuracy_score(y_true, chatgpt_pred)
    chatgpt_precision = precision_score(y_true, chatgpt_pred, average='weighted')
    chatgpt_recall = recall_score(y_true, chatgpt_pred, average='weighted')
    chatgpt_f1 = f1_score(y_true, chatgpt_pred, average='weighted')
    chatgpt_report = classification_report(y_true, chatgpt_pred, target_names=['negative', 'neutral', 'positive'])

    # Deepseek指标
    deepseek_accuracy = accuracy_score(y_true, deepseek_pred)
    deepseek_precision = precision_score(y_true, deepseek_pred, average='weighted')
    deepseek_recall = recall_score(y_true, deepseek_pred, average='weighted')
    deepseek_f1 = f1_score(y_true, deepseek_pred, average='weighted')
    deepseek_report = classification_report(y_true, deepseek_pred, target_names=['negative', 'neutral', 'positive'])

    # ============= 新增可视化 =============
    # 混淆矩阵
    def plot_confusion_matrix(y_true, y_pred, model_name):
        cm = confusion_matrix(y_true, y_pred, labels=[0, 1, 2])
        plt.figure(figsize=(6, 5))
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
                    xticklabels=['negative', 'neutral', 'positive'],
                    yticklabels=['negative', 'neutral', 'positive'])
        plt.title(f'{model_name}混淆矩阵')
        plt.xlabel('预测标签')
        plt.ylabel('真实标签')
        plt.savefig(f'{model_name}_confusion_matrix.png')
        plt.close()

    plot_confusion_matrix(y_true, chatgpt_pred, 'ChatGPT')
    plot_confusion_matrix(y_true, deepseek_pred, 'Deepseek')

    # 指标对比柱状图
    metrics = ['Accuracy', 'Precision', 'Recall', 'F1']
    chatgpt_scores = [chatgpt_accuracy, chatgpt_precision, chatgpt_recall, chatgpt_f1]
    deepseek_scores = [deepseek_accuracy, deepseek_precision, deepseek_recall, deepseek_f1]

    plt.figure(figsize=(10, 6))
    x = np.arange(len(metrics))
    width = 0.35
    plt.bar(x - width/2, chatgpt_scores, width, label='ChatGPT')
    plt.bar(x + width/2, deepseek_scores, width, label='Deepseek')
    plt.xticks(x, metrics)
    plt.ylim(0, 1)
    plt.ylabel('分数')
    plt.title('模型性能对比')
    plt.legend()
    plt.savefig('metrics_comparison.png')
    plt.close()

    # 返回所有指标
    return {
        'chatgpt': {
            'accuracy': chatgpt_accuracy,
            'precision': chatgpt_precision,
            'recall': chatgpt_recall,
            'f1': chatgpt_f1,
            'report': chatgpt_report
        },
        'deepseek': {
            'accuracy': deepseek_accuracy,
            'precision': deepseek_precision,
            'recall': deepseek_recall,
            'f1': deepseek_f1,
            'report': deepseek_report
        }
    }

def train_and_evaluate(model, X_train, y_train, X_test, y_test, epochs=5, batch_size=32):
    """训练和评估模型"""
    history = model.fit(
        X_train, y_train,
        epochs=epochs,
        batch_size=batch_size,
        validation_split=0.2,
        verbose=1
    )

    y_pred = model.predict(X_test)
    y_pred_classes = np.argmax(y_pred, axis=1)

    accuracy = accuracy_score(y_test, y_pred_classes)
    f1 = f1_score(y_test, y_pred_classes, average='weighted')

    return history, accuracy, f1

def create_lstm_model(vocab_size, max_length):
    model = Sequential([
        Embedding(vocab_size, 128, input_length=max_length),
        Bidirectional(LSTM(64, dropout=0.2, recurrent_dropout=0.2)),  # 改为双向
        Dense(64, activation='relu'),
        Dropout(0.3),  # 降低丢弃率
        Dense(3, activation='softmax')
    ])
    model.compile(
        optimizer=tf.keras.optimizers.Adam(learning_rate=1e-3),
        loss='sparse_categorical_crossentropy',
        metrics=['accuracy']
    )
    return model

def main():
    # 加载数据
    print("加载数据...")
    train_df = pd.read_csv('train.csv')
    test_df = pd.read_csv('test.csv')

    print(f"训练集大小: {train_df.shape}")
    print(f"测试集大小: {test_df.shape}")

    # 数据预处理
    print("数据预处理...")
    train_df['text'] = train_df['text'].apply(clean_text)
    test_df['text'] = test_df['text'].apply(clean_text)

    # 情感标签编码
    sentiment_mapping = {'positive': 2, 'neutral': 1, 'negative': 0}
    train_df['sentiment_encoded'] = train_df['sentiment'].map(sentiment_mapping)
    test_df['sentiment_encoded'] = test_df['sentiment'].map(sentiment_mapping)

    # 文本向量化
    print("文本向量化...")
    tokenizer = Tokenizer(num_words=10000)
    tokenizer.fit_on_texts(train_df['text'])

    max_length = 100
    X_train = tokenizer.texts_to_sequences(train_df['text'])
    X_test = tokenizer.texts_to_sequences(test_df['text'])

    X_train = pad_sequences(X_train, maxlen=max_length, padding='post')
    X_test = pad_sequences(X_test, maxlen=max_length, padding='post')

    y_train = train_df['sentiment_encoded']
    y_test = test_df['sentiment_encoded']



     # 评估生成式模型
    results = evaluate_generative_models(test_df)

    # 打印分类报告
    print("\nChatGPT分类报告:")
    print(results['chatgpt']['report'])

    print("\nDeepseek分类报告:")
    print(results['deepseek']['report'])

    # 结果比较表格
    print("\n模型性能比较:")
    comparison_df = pd.DataFrame({
        'Model': ['ChatGPT', 'Deepseek'],
        'Accuracy': [results['chatgpt']['accuracy'], results['deepseek']['accuracy']],
        'Precision': [results['chatgpt']['precision'], results['deepseek']['precision']],
        'Recall': [results['chatgpt']['recall'], results['deepseek']['recall']],
        'F1': [results['chatgpt']['f1'], results['deepseek']['f1']]
    })
    print(comparison_df)

    # 保存结果到CSV
    comparison_df.to_csv('model_comparison.csv', index=False)
    print("\n结果已保存到 model_comparison.csv")

if __name__ == "__main__":
    main()
